<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Serapi_protocol (coq-serapi.Serapi_protocol)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../index.html">Up</a> – <a href="../index.html">coq-serapi</a> &#x00BB; Serapi_protocol</nav><h1>Module <code>Serapi_protocol</code></h1><p>The SerAPI Protocol</p><nav class="toc"><ul><li><a href="#history:">History:</a></li><li><a href="#users:">Users:</a></li><li><a href="#basic-overview-of-the-protocol:">Basic Overview of the Protocol:</a><ul><li><a href="#document-creation-and-checking:">Document creation and checking:</a><ul><li><a href="#sentence-checking">Sentence Checking</a></li><li><a href="#modification-of-the-document">Modification of the Document</a><ul><li><a href="#caveats">Caveats</a></li></ul></li></ul></li><li><a href="#querying-documents:">Querying documents:</a></li></ul></li><li><a href="#non-interactive-use">Non-interactive use</a></li><li><a href="#protocol-specification">Protocol Specification</a><ul><li><a href="#basic-protocol-objects">Basic Protocol Objects</a></li><li><a href="#printing-options">Printing Options</a></li><li><a href="#query-sub-protocol">Query Sub-Protocol</a></li><li><a href="#control-sub-protocol">Control Sub-Protocol</a><ul><li><a href="#adding-a-new-sentence">Adding a new sentence</a></li><li><a href="#creating-a-new-document">Creating a new document</a></li></ul></li><li><a href="#top-level-protocol">Top Level Protocol</a></li><li><a href="#entry-points-to-the-dsl-evaluator">Entry points to the DSL evaluator</a></li></ul></li></ul></nav></header><aside><p>SerAPI is a set of utilities designed to help users and tool creators to interact with <a href="https://coq.inria.fr">Coq</a> in a systematic way; in particular, SerAPI was designed to provide full serialization and de-serialization of key Coq structures, including user-level AST and kernel terms.</p><p>SerAPI also provides a reification of Coq's document building API, making it pretty easy to build and check systematically Coq documents.</p><p>As of today SerAPI does provide the following components:</p><ul><li><code>serlib</code>: A library providing serializers for core Coq structures; the main serialization format is S-expressions, as <code>serlib</code> is based on the excellent <a href="https://github.com/janestreet/ppx_sexp_conv">ppx_sexp_conv</a> from Jane Street. Support for JSON is currently under development.</li><li><code>sertop</code>: A toplevel executable exposing a simple document building and querying protocol. This is the main component, we document it properly below.</li><li><code>sercomp</code>: A simple compiler utility for .v files that can input and output Coq files in a variety of formats. See its manual for more help.</li><li><code>serload</code>: TODO</li></ul></aside><section><header><h3 id="history:"><a href="#history:" class="anchor"></a>History:</h3><p>SerAPI was a <a href="https://github.com/ejgallego/jscoq">JsCoq</a> offspring project; JsCoq added experimental serialization of Coq terms, however we quickly realized that this facility would be helpful in the general setting; we also took advantage of the serialization facilities to specify the Coq building API as a DSL; the client for the tool was an <a href="https://github.com/cpitclaudel/elcoq">experimental Emacs mode</a> by Clément Pit-Claudel.</p><p>The next step was to provide reliable &quot;round-trip&quot; (de)serialization of full Coq documents; Karl Palmskog contributed the round trip testing infrastructure to make this happen.</p></header></section><section><header><h3 id="users:"><a href="#users:" class="anchor"></a>Users:</h3><p>SerAPI is a bit of a swiss army knife, in the sense that it is a general &quot;talk to Coq&quot; tool and can do many things; a good way to understand the tool is look at some of its users, see the list of them in the <a href="https://github.com/ejgallego/coq-serapi/">Project's README</a></p></header></section><section><header><h3 id="basic-overview-of-the-protocol:"><a href="#basic-overview-of-the-protocol:" class="anchor"></a>Basic Overview of the Protocol:</h3><p>SerAPI protocol can be divided in two main sets of operations: document creation and checking, and document querying.</p><p>Note that the protocol is fully specified as a DSL written in OCaml; thus, its canonical specification can be found below as documents to the OCaml code. In this section, we attempt a brief introduction, but the advanced user will without doubt want to look at the details just below.</p></header><section><header><h4 id="document-creation-and-checking:"><a href="#document-creation-and-checking:" class="anchor"></a>Document creation and checking:</h4><p>Before you can use SerAPI to extract any information about a Coq document, you must indeed have Coq parse and process the document. Coq's parsing process is quite complicated due to user-extensibility, but SerAPI tries to smooth the experience as much as possible.</p><p>A Coq document is basically a list of sentences which are uniquely identified by a <code>Stateid.t</code> object; for our purposes this identifier is an integer.</p><p><b>Note:</b> <em>In future versions, sentence id will be deprecated, and instead we will use Language Server Protocol-style locations inside the document to identify sentences.</em></p><p>Each sentence has a &quot;parent&quot;, that is to say, a previous sentence; the initial sentence has as a parent <code>sid = 1</code> (<code>sid</code> = sentence id).</p><p>Note that the parent is important for parsing as it may modify the parsing itself, for example it may be a <code>Notation</code> command.</p><p>Thus, to build or append to a Coq document, you should select a parent sentence and ask SerAPI to add some new ones. This is achieved with the <code>(Add (opts) &quot;text&quot;)</code> command.</p><p>See below for a detailed overview of <code>Add</code>, but the basic idea is that Coq will parse and add to the current document as many sentences as you have sent to it. Unfortunately, sentence number for the newly added ones is not always predictable but there are workarounds for that.</p><p>If succesfull, <code>Add</code> will send back an <code>Added</code> message with the location and new sentence identifier. This is useful to let SerAPI do the splitting of sentences for you. A typical use thus is:</p><p><code>(Add () &quot;Lemma addnC n : n + 0 = n. Proof. now induction n. Qed.&quot;)</code></p><p>This will return 4 answers.</p></header><section><header><h5 id="sentence-checking"><a href="#sentence-checking" class="anchor"></a>Sentence Checking</h5><p>Adding a set of sentences basically amounts to parsing, however in most cases Coq won't try to typecheck or run the tactics at hand. For that purpose you can use the <code>(Exec sid)</code> command. Taking a sentence id, <code>Check</code> will actually check <code>sid</code> and all the sentences <code>sid</code> depends upon.</p><p>Note that in some modes Coq can skip proofs here, so in order to get a fully-checked document you may have to issue <code>Check</code> for every sentence on it. Checking a sentence twice is usually a noop.</p></header></section><section><header><h5 id="modification-of-the-document"><a href="#modification-of-the-document" class="anchor"></a>Modification of the Document</h5><p>In order to modify a &quot;live&quot; document, SerAPI does provide a <code>(Cancel sid)</code> command. <code>Cancel</code> will take a sentence id and return the list of sentences that are not valid anymore.</p><p>Thus, you can edit a document by cancelling and re-adding sentences.</p></header><section><header><h6 id="caveats"><a href="#caveats" class="anchor"></a>Caveats</h6><p>Cancelling a non-executed part is poorly supported by the underlying Coq checking algorithm. In particular, <code>Cancel</code> will force execution up to the previous sentence; thus it is not possible to parse a list of sentences and then replace them without incurring in the cost of executing them. In particular, it could be even the case that after issuing <code>Cancel sid</code>, there is an error in the execution of an unrelated sentence. It should be possible to identify this sentence using the exception attributes. As of today, this remains a hard-limitation of the STM.</p></header></section></section></section><section><header><h4 id="querying-documents:"><a href="#querying-documents:" class="anchor"></a>Querying documents:</h4><p>For a particular point on the document, you can query Coq for information about it. Common query use cases are for example lists of tactics, AST, completion, etc... Querying is done using the <code>(Query (opts) query)</code> command. The full specification can be found below.</p><p>A particulary of <code>Query</code> is that the caller must set all the pertinent output options. For example, if the query should return for-humans data or machine-readable one.</p></header></section></section><section><header><h3 id="non-interactive-use"><a href="#non-interactive-use" class="anchor"></a>Non-interactive use</h3><p>In many cases, non-interactive use is very convenient; for that, we recommend you read the help of the `sercomp` compiler.</p></header></section><section><header><h3 id="protocol-specification"><a href="#protocol-specification" class="anchor"></a>Protocol Specification</h3></header><section><header><h4 id="basic-protocol-objects"><a href="#basic-protocol-objects" class="anchor"></a>Basic Protocol Objects</h4><p>SerAPI can return different kinds of objects as an answer to queries; object type is usually distinguished by a tag, for example <code>(CoqString &quot;foo&quot;)</code> or <code>(CoqConstr (App ...)</code></p><p>Serialization representation is derived from the OCaml representation automatically, thus the best is to use Merlin or some OCaml-browsing tool as to know the internal of each type; we provide a brief description of each object:</p></header><dl><dt class="spec type" id="type-coq_object"><a href="#type-coq_object" class="anchor"></a><code><span class="keyword">type</span> coq_object</code><code> = </code><table class="variant"><tr id="type-coq_object.CoqString" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqString" class="anchor"></a><code>| </code><code><span class="constructor">CoqString</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>A string</p></td></tr><tr id="type-coq_object.CoqSList" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqSList" class="anchor"></a><code>| </code><code><span class="constructor">CoqSList</span> <span class="keyword">of</span> <span>string list</span></code></td><td class="doc"><p>A list of strings</p></td></tr><tr id="type-coq_object.CoqPp" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqPp" class="anchor"></a><code>| </code><code><span class="constructor">CoqPp</span> <span class="keyword">of</span> Pp.t</code></td><td class="doc"><p>A Coq &quot;Pretty Printing&quot; Document type, main type used by Coq to submit formatted output</p></td></tr><tr id="type-coq_object.CoqLoc" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqLoc" class="anchor"></a><code>| </code><code><span class="constructor">CoqLoc</span> <span class="keyword">of</span> Loc.t</code></td><td class="doc"><p>A Coq Location object, used for positions inside the document.</p></td></tr><tr id="type-coq_object.CoqTok" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqTok" class="anchor"></a><code>| </code><code><span class="constructor">CoqTok</span> <span class="keyword">of</span> <span><span>Tok.t CAst.t</span> list</span></code></td><td class="doc"><p>Coq Tokens, as produced by the lexer</p></td></tr><tr id="type-coq_object.CoqAst" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqAst" class="anchor"></a><code>| </code><code><span class="constructor">CoqAst</span> <span class="keyword">of</span> <span>Vernacexpr.vernac_control Loc.located</span></code></td><td class="doc"><p>Coq Abstract Syntax tress, as produced by the parser</p></td></tr><tr id="type-coq_object.CoqOption" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqOption" class="anchor"></a><code>| </code><code><span class="constructor">CoqOption</span> <span class="keyword">of</span> Goptions.option_name * Goptions.option_state</code></td><td class="doc"><p>Coq Options, as in <code>Set Resolution Depth</code></p></td></tr><tr id="type-coq_object.CoqConstr" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqConstr" class="anchor"></a><code>| </code><code><span class="constructor">CoqConstr</span> <span class="keyword">of</span> Constr.constr</code></td><td class="doc"><p>Coq Kernel terms, this is the fundamental representation for terms of the Calculus of Inductive constructions</p></td></tr><tr id="type-coq_object.CoqExpr" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqExpr" class="anchor"></a><code>| </code><code><span class="constructor">CoqExpr</span> <span class="keyword">of</span> Constrexpr.constr_expr</code></td><td class="doc"><p>Coq term ASTs, this is the user-level parsing tree of terms</p></td></tr><tr id="type-coq_object.CoqMInd" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqMInd" class="anchor"></a><code>| </code><code><span class="constructor">CoqMInd</span> <span class="keyword">of</span> Names.MutInd.t * Declarations.mutual_inductive_body</code></td><td class="doc"><p>Coq kernel-level inductive; this is a low-level object that contains all the details of an inductive.</p></td></tr><tr id="type-coq_object.CoqEnv" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqEnv" class="anchor"></a><code>| </code><code><span class="constructor">CoqEnv</span> <span class="keyword">of</span> Environ.env</code></td><td class="doc"><p>Coq kernel-level enviroments: they do provide the full information about what the kernel know, heavy.</p></td></tr><tr id="type-coq_object.CoqTactic" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqTactic" class="anchor"></a><code>| </code><code><span class="constructor">CoqTactic</span> <span class="keyword">of</span> Names.KerName.t * Ltac_plugin.Tacenv.ltac_entry</code></td><td class="doc"><p>Representation of an Ltac tactic definition</p></td></tr><tr id="type-coq_object.CoqLtac" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqLtac" class="anchor"></a><code>| </code><code><span class="constructor">CoqLtac</span> <span class="keyword">of</span> Ltac_plugin.Tacexpr.raw_tactic_expr</code></td><td class="doc"><p>AST of an LTAC tactic definition</p></td></tr><tr id="type-coq_object.CoqGenArg" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqGenArg" class="anchor"></a><code>| </code><code><span class="constructor">CoqGenArg</span> <span class="keyword">of</span> Genarg.raw_generic_argument</code></td><td class="doc"><p>Coq Generic argument, can contain any type</p></td></tr><tr id="type-coq_object.CoqQualId" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqQualId" class="anchor"></a><code>| </code><code><span class="constructor">CoqQualId</span> <span class="keyword">of</span> Libnames.qualid</code></td><td class="doc"><p>Qualified identifier</p></td></tr><tr id="type-coq_object.CoqGlobRef" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqGlobRef" class="anchor"></a><code>| </code><code><span class="constructor">CoqGlobRef</span> <span class="keyword">of</span> Names.GlobRef.t</code></td><td class="doc"><p>&quot;Global Reference&quot;, which is a type that can point to a module, a constant, a variable, a constructor...</p></td></tr><tr id="type-coq_object.CoqGlobRefExt" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqGlobRefExt" class="anchor"></a><code>| </code><code><span class="constructor">CoqGlobRefExt</span> <span class="keyword">of</span> Globnames.extended_global_reference</code></td><td class="doc"><p>&quot;Extended Global Reference&quot;, as they can contain syntactic definitions too</p></td></tr><tr id="type-coq_object.CoqImplicit" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqImplicit" class="anchor"></a><code>| </code><code><span class="constructor">CoqImplicit</span> <span class="keyword">of</span> Impargs.implicits_list</code></td><td class="doc"><p>Implicit status for a constant</p></td></tr><tr id="type-coq_object.CoqProfData" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqProfData" class="anchor"></a><code>| </code><code><span class="constructor">CoqProfData</span> <span class="keyword">of</span> Ltac_plugin.Profile_ltac.treenode</code></td><td class="doc"><p>Ltac Profiler data</p></td></tr><tr id="type-coq_object.CoqNotation" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqNotation" class="anchor"></a><code>| </code><code><span class="constructor">CoqNotation</span> <span class="keyword">of</span> Constrexpr.notation</code></td><td class="doc"><p>Representation of a notation (usually a string)</p></td></tr><tr id="type-coq_object.CoqUnparsing" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqUnparsing" class="anchor"></a><code>| </code><code><span class="constructor">CoqUnparsing</span> <span class="keyword">of</span> Ppextend.unparsing_rule * Ppextend.extra_unparsing_rules * Notation_gram.notation_grammar</code></td><td class="doc"><p>Rules for notation printing and some internals</p></td></tr><tr id="type-coq_object.CoqGoal" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqGoal" class="anchor"></a><code>| </code><code><span class="constructor">CoqGoal</span> <span class="keyword">of</span> <span><span>Constr.t <a href="../Serapi_goals/index.html#type-reified_goal">Serapi_goals.reified_goal</a></span> <a href="../Serapi_goals/index.html#type-ser_goals">Serapi_goals.ser_goals</a></span></code></td><td class="doc"><p>Goals, with types and terms in Kernel-level representation</p></td></tr><tr id="type-coq_object.CoqExtGoal" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqExtGoal" class="anchor"></a><code>| </code><code><span class="constructor">CoqExtGoal</span> <span class="keyword">of</span> <span><span>Constrexpr.constr_expr <a href="../Serapi_goals/index.html#type-reified_goal">Serapi_goals.reified_goal</a></span> <a href="../Serapi_goals/index.html#type-ser_goals">Serapi_goals.ser_goals</a></span></code></td><td class="doc"><p>Goals, with types and terms in user-level, AST representation</p></td></tr><tr id="type-coq_object.CoqProof" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqProof" class="anchor"></a><code>| </code><code><span class="constructor">CoqProof</span> <span class="keyword">of</span> <span>Goal.goal list</span> * <span><span>(<span>Goal.goal list</span> * <span>Goal.goal list</span>)</span> list</span> * <span>Goal.goal list</span> * <span>Goal.goal list</span></code></td><td class="doc"><p>Proof object: really low-level and likely to be deprecated.</p></td></tr><tr id="type-coq_object.CoqAssumptions" class="anchored"><td class="def constructor"><a href="#type-coq_object.CoqAssumptions" class="anchor"></a><code>| </code><code><span class="constructor">CoqAssumptions</span> <span class="keyword">of</span> <a href="../Serapi_assumptions/index.html#type-t">Serapi_assumptions.t</a></code></td><td class="doc"><p>Structured representation of the assumptions of a constant.</p></td></tr></table></dt></dl></section><section><header><h4 id="printing-options"><a href="#printing-options" class="anchor"></a>Printing Options</h4></header><dl><dt class="spec type" id="type-print_format"><a href="#type-print_format" class="anchor"></a><code><span class="keyword">type</span> print_format</code><code> = </code><table class="variant"><tr id="type-print_format.PpSer" class="anchored"><td class="def constructor"><a href="#type-print_format.PpSer" class="anchor"></a><code>| </code><code><span class="constructor">PpSer</span></code></td><td class="doc"><p>Output in serialized format <code>usually sexp</code></p></td></tr><tr id="type-print_format.PpStr" class="anchored"><td class="def constructor"><a href="#type-print_format.PpStr" class="anchor"></a><code>| </code><code><span class="constructor">PpStr</span></code></td><td class="doc"><p>Output a string with a human-friendly representation</p></td></tr><tr id="type-print_format.PpTex" class="anchored"><td class="def constructor"><a href="#type-print_format.PpTex" class="anchor"></a><code>| </code><code><span class="constructor">PpTex</span></code></td><td class="doc"><p>Output a TeX expression</p></td></tr><tr id="type-print_format.PpCoq" class="anchored"><td class="def constructor"><a href="#type-print_format.PpCoq" class="anchor"></a><code>| </code><code><span class="constructor">PpCoq</span></code></td><td class="doc"><p>Output a Coq <code>Pp.t</code>, representation-indepedent document</p></td></tr></table></dt><dd><p>Query output format</p></dd></dl><dl><dt class="spec type" id="type-format_opt"><a href="#type-format_opt" class="anchor"></a><code><span class="keyword">type</span> format_opt</code><code> = </code><code>{</code><table class="record"><tr id="type-format_opt.pp_format" class="anchored"><td class="def field"><a href="#type-format_opt.pp_format" class="anchor"></a><code>pp_format : <a href="index.html#type-print_format">print_format</a>;</code></td><td class="doc"><p>Output format (<em>default PpSer</em>)</p></td></tr><tr id="type-format_opt.pp_depth" class="anchored"><td class="def field"><a href="#type-format_opt.pp_depth" class="anchor"></a><code>pp_depth : int;</code></td><td class="doc"><p>Depth (<em>default 0</em>)</p></td></tr><tr id="type-format_opt.pp_elide" class="anchored"><td class="def field"><a href="#type-format_opt.pp_elide" class="anchor"></a><code>pp_elide : string;</code></td><td class="doc"><p>Elipsis (<em>default: &quot;...&quot;</em>)</p></td></tr><tr id="type-format_opt.pp_margin" class="anchored"><td class="def field"><a href="#type-format_opt.pp_margin" class="anchor"></a><code>pp_margin : int;</code></td><td class="doc"><p>Margin (<em>default: 72</em>)</p></td></tr></table><code>}</code></dt><dd><p>Printing options, not all options are relevant for all printing backends</p></dd></dl><dl><dt class="spec type" id="type-print_opt"><a href="#type-print_opt" class="anchor"></a><code><span class="keyword">type</span> print_opt</code><code> = </code><code>{</code><table class="record"><tr id="type-print_opt.sid" class="anchored"><td class="def field"><a href="#type-print_opt.sid" class="anchor"></a><code>sid : Stateid.t;</code></td><td class="doc"><p><code>sid</code> denotes the <em>sentence id</em> we are querying over, essential information as goals for example will vary.</p></td></tr><tr id="type-print_opt.pp" class="anchored"><td class="def field"><a href="#type-print_opt.pp" class="anchor"></a><code>pp : <a href="index.html#type-format_opt">format_opt</a>;</code></td><td class="doc"><p>Printing format of the query, this can be used to select the type of the answer, as for example to show goals in human-form.</p></td></tr></table><code>}</code></dt></dl><dl><dt class="spec value" id="val-gen_pp_obj"><a href="#val-gen_pp_obj" class="anchor"></a><code><span class="keyword">val</span> gen_pp_obj : Environ.env <span>&#45;&gt;</span> Evd.evar_map <span>&#45;&gt;</span> <a href="index.html#type-coq_object">coq_object</a> <span>&#45;&gt;</span> Pp.t</code></dt></dl></section><section><header><h4 id="query-sub-protocol"><a href="#query-sub-protocol" class="anchor"></a>Query Sub-Protocol</h4></header><dl><dt class="spec type" id="type-query_pred"><a href="#type-query_pred" class="anchor"></a><code><span class="keyword">type</span> query_pred</code><code> = </code><table class="variant"><tr id="type-query_pred.Prefix" class="anchored"><td class="def constructor"><a href="#type-query_pred.Prefix" class="anchor"></a><code>| </code><code><span class="constructor">Prefix</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Filter named objects based on the given prefix</p></td></tr></table></dt><dd><p>Predicates on the queries. This is at the moment mostly a token functionality</p></dd></dl><dl><dt class="spec type" id="type-query_opt"><a href="#type-query_opt" class="anchor"></a><code><span class="keyword">type</span> query_opt</code><code> = </code><code>{</code><table class="record"><tr id="type-query_opt.preds" class="anchored"><td class="def field"><a href="#type-query_opt.preds" class="anchor"></a><code>preds : <span><a href="index.html#type-query_pred">query_pred</a> Sexplib.Conv.sexp_list</span>;</code></td><td class="doc"><p>List of predicates on queries, mostly a placeholder, will allow to add filtering conditions in the future</p></td></tr><tr id="type-query_opt.limit" class="anchored"><td class="def field"><a href="#type-query_opt.limit" class="anchor"></a><code>limit : <span>int Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>Limit the number of results, should evolve into an API with resume functionality, maybe we adopt LSP conventions here</p></td></tr><tr id="type-query_opt.sid" class="anchored"><td class="def field"><a href="#type-query_opt.sid" class="anchor"></a><code>sid : Stateid.t;</code></td><td class="doc"><p><code>sid</code> denotes the <em>sentence id</em> we are querying over, essential information as goals for example will vary.</p></td></tr><tr id="type-query_opt.pp" class="anchored"><td class="def field"><a href="#type-query_opt.pp" class="anchor"></a><code>pp : <a href="index.html#type-format_opt">format_opt</a>;</code></td><td class="doc"><p>Printing format of the query, this can be used to select the type of the answer, as for example to show goals in human-form.</p></td></tr><tr id="type-query_opt.route" class="anchored"><td class="def field"><a href="#type-query_opt.route" class="anchor"></a><code>route : Feedback.route_id;</code></td><td class="doc"><p>Legacy/Deprecated STM query method</p></td></tr></table><code>}</code></dt><dd><p>Query options, note the default values that help interactive use, however in mechanized use we do not recommend skipping any field</p></dd></dl><dl><dt class="spec type" id="type-query_cmd"><a href="#type-query_cmd" class="anchor"></a><code><span class="keyword">type</span> query_cmd</code><code> = </code><table class="variant"><tr id="type-query_cmd.Option" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Option" class="anchor"></a><code>| </code><code><span class="constructor">Option</span></code></td><td class="doc"><p>List of options Coq knows about</p></td></tr><tr id="type-query_cmd.Search" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Search" class="anchor"></a><code>| </code><code><span class="constructor">Search</span></code></td><td class="doc"><p>Query version of the <code>Search</code> command</p></td></tr><tr id="type-query_cmd.Goals" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Goals" class="anchor"></a><code>| </code><code><span class="constructor">Goals</span></code></td><td class="doc"><p>Current goals, in kernel form</p></td></tr><tr id="type-query_cmd.EGoals" class="anchored"><td class="def constructor"><a href="#type-query_cmd.EGoals" class="anchor"></a><code>| </code><code><span class="constructor">EGoals</span></code></td><td class="doc"><p>Current goals, in AST form</p></td></tr><tr id="type-query_cmd.Ast" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Ast" class="anchor"></a><code>| </code><code><span class="constructor">Ast</span></code></td><td class="doc"><p>Ast for the current sentence</p></td></tr><tr id="type-query_cmd.TypeOf" class="anchored"><td class="def constructor"><a href="#type-query_cmd.TypeOf" class="anchor"></a><code>| </code><code><span class="constructor">TypeOf</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Type of an expression (unimplemented?)</p></td></tr><tr id="type-query_cmd.Names" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Names" class="anchor"></a><code>| </code><code><span class="constructor">Names</span> <span class="keyword">of</span> string</code></td><td class="doc"><p><code>(Names prefix)</code> will return the list of identifiers Coq knows that start with <code>prefix</code></p></td></tr><tr id="type-query_cmd.Tactics" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Tactics" class="anchor"></a><code>| </code><code><span class="constructor">Tactics</span> <span class="keyword">of</span> string</code></td><td class="doc"><p><code>(Tactcis prefix)</code> will return the list of tactics Coq knows that start with <code>prefix</code></p></td></tr><tr id="type-query_cmd.Locate" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Locate" class="anchor"></a><code>| </code><code><span class="constructor">Locate</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Query version of the <code>Locate</code> commands</p></td></tr><tr id="type-query_cmd.Implicits" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Implicits" class="anchor"></a><code>| </code><code><span class="constructor">Implicits</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Return information of implicits for a given constant</p></td></tr><tr id="type-query_cmd.Unparsing" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Unparsing" class="anchor"></a><code>| </code><code><span class="constructor">Unparsing</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Return internal information for a given notation</p></td></tr><tr id="type-query_cmd.Definition" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Definition" class="anchor"></a><code>| </code><code><span class="constructor">Definition</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Return the definition for a given global</p></td></tr><tr id="type-query_cmd.PNotations" class="anchored"><td class="def constructor"><a href="#type-query_cmd.PNotations" class="anchor"></a><code>| </code><code><span class="constructor">PNotations</span></code></td><td class="doc"><p>Return a list of notations</p></td></tr><tr id="type-query_cmd.ProfileData" class="anchored"><td class="def constructor"><a href="#type-query_cmd.ProfileData" class="anchor"></a><code>| </code><code><span class="constructor">ProfileData</span></code></td><td class="doc"><p>Return LTAC profile data, if any</p></td></tr><tr id="type-query_cmd.Proof" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Proof" class="anchor"></a><code>| </code><code><span class="constructor">Proof</span></code></td><td class="doc"><p>Return the proof object <code>low-level</code></p></td></tr><tr id="type-query_cmd.Vernac" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Vernac" class="anchor"></a><code>| </code><code><span class="constructor">Vernac</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Execute an arbitrary Coq command in an isolated state.</p></td></tr><tr id="type-query_cmd.Env" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Env" class="anchor"></a><code>| </code><code><span class="constructor">Env</span></code></td><td class="doc"><p>Return the current enviroment</p></td></tr><tr id="type-query_cmd.Assumptions" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Assumptions" class="anchor"></a><code>| </code><code><span class="constructor">Assumptions</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Return the assumptions of a given global</p></td></tr><tr id="type-query_cmd.Complete" class="anchored"><td class="def constructor"><a href="#type-query_cmd.Complete" class="anchor"></a><code>| </code><code><span class="constructor">Complete</span> <span class="keyword">of</span> string</code></td><td class="doc"><p>Naïve but efficient prefix-based completion of identifiers</p></td></tr></table></dt><dd><p>Query commands are mostly a tag and some arguments determining the result type.</p><p><b>Important</b> Note that <code>Query</code> won't force execution of a particular state, thus for example if you do <code>(Query ((sid 3)) Goals)</code> and the sentence <code>3</code> wasn't evaluated, then the query will return zero answers.</p><p>We would ideally evolve towards a true query language, likley having <code>query_cmd</code> and <code>coq_object</code> be typed such that query : 'a query -&gt; 'a coq_object.</p></dd></dl><div class="spec module" id="module-QueryUtil"><a href="#module-QueryUtil" class="anchor"></a><code><span class="keyword">module</span> <a href="QueryUtil/index.html">QueryUtil</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div></section><section><header><h4 id="control-sub-protocol"><a href="#control-sub-protocol" class="anchor"></a>Control Sub-Protocol</h4></header><section><header><h5 id="adding-a-new-sentence"><a href="#adding-a-new-sentence" class="anchor"></a>Adding a new sentence</h5></header><dl><dt class="spec type" id="type-parse_opt"><a href="#type-parse_opt" class="anchor"></a><code><span class="keyword">type</span> parse_opt</code><code> = </code><code>{</code><table class="record"><tr id="type-parse_opt.ontop" class="anchored"><td class="def field"><a href="#type-parse_opt.ontop" class="anchor"></a><code>ontop : <span>Stateid.t Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>parse <code>ontop</code> of the given sentence</p></td></tr></table><code>}</code></dt><dt class="spec type" id="type-add_opts"><a href="#type-add_opts" class="anchor"></a><code><span class="keyword">type</span> add_opts</code><code> = </code><code>{</code><table class="record"><tr id="type-add_opts.lim" class="anchored"><td class="def field"><a href="#type-add_opts.lim" class="anchor"></a><code>lim : <span>int Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>Parse <code>lim</code> sentences at most (<code>None</code> == no limit)</p></td></tr><tr id="type-add_opts.ontop" class="anchored"><td class="def field"><a href="#type-add_opts.ontop" class="anchor"></a><code>ontop : <span>Stateid.t Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>parse <code>ontop</code> of the given sentence</p></td></tr><tr id="type-add_opts.newtip" class="anchored"><td class="def field"><a href="#type-add_opts.newtip" class="anchor"></a><code>newtip : <span>Stateid.t Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>Make <code>newtip</code> the new sentence id, very useful to avoid synchronous operations</p></td></tr><tr id="type-add_opts.verb" class="anchored"><td class="def field"><a href="#type-add_opts.verb" class="anchor"></a><code>verb : bool;</code></td><td class="doc"><p><code>verb</code> internal Coq parameter, be verbose on parsing</p></td></tr></table><code>}</code></dt><dd><p><code>Add</code> will take a string and parse all the sentences on it, until an error of the end is found. Options for <code>Add</code> are:</p></dd></dl></section><section><header><h5 id="creating-a-new-document"><a href="#creating-a-new-document" class="anchor"></a>Creating a new document</h5><p><b>experimental</b></p></header><dl><dt class="spec type" id="type-newdoc_opts"><a href="#type-newdoc_opts" class="anchor"></a><code><span class="keyword">type</span> newdoc_opts</code><code> = </code><code>{</code><table class="record"><tr id="type-newdoc_opts.top_name" class="anchored"><td class="def field"><a href="#type-newdoc_opts.top_name" class="anchor"></a><code>top_name : Stm.interactive_top;</code></td><td class="doc"><p>name of the top-level module of the new document</p></td></tr><tr id="type-newdoc_opts.iload_path" class="anchored"><td class="def field"><a href="#type-newdoc_opts.iload_path" class="anchor"></a><code>iload_path : <span><span>Mltop.coq_path list</span> Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>Initial LoadPath for the document</p></td></tr><tr id="type-newdoc_opts.require_libs" class="anchored"><td class="def field"><a href="#type-newdoc_opts.require_libs" class="anchor"></a><code>require_libs : <span><span><span>(string * <span>string option</span> * <span>bool option</span>)</span> list</span> Sexplib.Conv.sexp_option</span>;</code></td><td class="doc"><p>Libraries to load in the initial document state</p></td></tr></table><code>}</code></dt></dl></section></section><section><header><h4 id="top-level-protocol"><a href="#top-level-protocol" class="anchor"></a>Top Level Protocol</h4><p>The top level protocol is the main input command to SerAPI, we detail each of the commands below.</p><p>The main interaction loop is as: 1. submit tagged command <code>(tag (Cmd args))</code> 2. receive tagged ack <code>(Answer tag Ack)</code> 3. receive tagged results, usually <code>(Answer tag (ObjList ...)</code> or <code>(Answer tag (CoqExn ...)</code> 4. receive tagged completion event <code>(Answer tag Completed)</code></p><p>The <code>Ack</code> and <code>Completed</code> events are always produced, and provide a kind of &quot;bracking&quot; for command execution.</p></header><dl><dt class="spec type" id="type-cmd"><a href="#type-cmd" class="anchor"></a><code><span class="keyword">type</span> cmd</code><code> = </code><table class="variant"><tr id="type-cmd.NewDoc" class="anchored"><td class="def constructor"><a href="#type-cmd.NewDoc" class="anchor"></a><code>| </code><code><span class="constructor">NewDoc</span> <span class="keyword">of</span> <a href="index.html#type-newdoc_opts">newdoc_opts</a></code></td><td class="doc"><p>Create a new document, experimental, only usable when <code>--no_init</code> was used.</p></td></tr><tr id="type-cmd.Add" class="anchored"><td class="def constructor"><a href="#type-cmd.Add" class="anchor"></a><code>| </code><code><span class="constructor">Add</span> <span class="keyword">of</span> <a href="index.html#type-add_opts">add_opts</a> * string</code></td><td class="doc"><p>Add a set of sentences to the current document</p></td></tr><tr id="type-cmd.Cancel" class="anchored"><td class="def constructor"><a href="#type-cmd.Cancel" class="anchor"></a><code>| </code><code><span class="constructor">Cancel</span> <span class="keyword">of</span> <span>Stateid.t list</span></code></td><td class="doc"><p>Remove a set of sentences from the current document</p></td></tr><tr id="type-cmd.Exec" class="anchored"><td class="def constructor"><a href="#type-cmd.Exec" class="anchor"></a><code>| </code><code><span class="constructor">Exec</span> <span class="keyword">of</span> Stateid.t</code></td><td class="doc"><p>Execute a particular sentence</p></td></tr><tr id="type-cmd.Query" class="anchored"><td class="def constructor"><a href="#type-cmd.Query" class="anchor"></a><code>| </code><code><span class="constructor">Query</span> <span class="keyword">of</span> <a href="index.html#type-query_opt">query_opt</a> * <a href="index.html#type-query_cmd">query_cmd</a></code></td><td class="doc"><p>Query a Coq document</p></td></tr><tr id="type-cmd.Print" class="anchored"><td class="def constructor"><a href="#type-cmd.Print" class="anchor"></a><code>| </code><code><span class="constructor">Print</span> <span class="keyword">of</span> <a href="index.html#type-print_opt">print_opt</a> * <a href="index.html#type-coq_object">coq_object</a></code></td><td class="doc"><p>Print some object</p></td></tr><tr id="type-cmd.Parse" class="anchored"><td class="def constructor"><a href="#type-cmd.Parse" class="anchor"></a><code>| </code><code><span class="constructor">Parse</span> <span class="keyword">of</span> <a href="index.html#type-parse_opt">parse_opt</a> * string</code></td><td class="doc"><p>Parse</p></td></tr><tr id="type-cmd.Join" class="anchored"><td class="def constructor"><a href="#type-cmd.Join" class="anchor"></a><code>| </code><code><span class="constructor">Join</span></code></td><td class="doc"><p>Be sure that a document is consistent</p></td></tr><tr id="type-cmd.Finish" class="anchored"><td class="def constructor"><a href="#type-cmd.Finish" class="anchor"></a><code>| </code><code><span class="constructor">Finish</span></code></td><td class="doc"><p>Internal</p></td></tr><tr id="type-cmd.ReadFile" class="anchored"><td class="def constructor"><a href="#type-cmd.ReadFile" class="anchor"></a><code>| </code><code><span class="constructor">ReadFile</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-cmd.Tokenize" class="anchored"><td class="def constructor"><a href="#type-cmd.Tokenize" class="anchor"></a><code>| </code><code><span class="constructor">Tokenize</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-cmd.Noop" class="anchored"><td class="def constructor"><a href="#type-cmd.Noop" class="anchor"></a><code>| </code><code><span class="constructor">Noop</span></code></td></tr><tr id="type-cmd.Help" class="anchored"><td class="def constructor"><a href="#type-cmd.Help" class="anchor"></a><code>| </code><code><span class="constructor">Help</span></code></td></tr><tr id="type-cmd.Quit" class="anchored"><td class="def constructor"><a href="#type-cmd.Quit" class="anchor"></a><code>| </code><code><span class="constructor">Quit</span></code></td></tr></table></dt><dd><p>Each top level command will produce an answers, see below for answer description.</p></dd></dl><dl><dt class="spec exception" id="exception-NoSuchState"><a href="#exception-NoSuchState" class="anchor"></a><code><span class="keyword">exception</span> </code><code><span class="exception">NoSuchState</span> <span class="keyword">of</span> Stateid.t</code></dt></dl><div class="spec module" id="module-ExnInfo"><a href="#module-ExnInfo" class="anchor"></a><code><span class="keyword">module</span> <a href="ExnInfo/index.html">ExnInfo</a> : <span class="keyword">sig</span> ... <span class="keyword">end</span></code></div><dl><dt class="spec type" id="type-answer_kind"><a href="#type-answer_kind" class="anchor"></a><code><span class="keyword">type</span> answer_kind</code><code> = </code><table class="variant"><tr id="type-answer_kind.Ack" class="anchored"><td class="def constructor"><a href="#type-answer_kind.Ack" class="anchor"></a><code>| </code><code><span class="constructor">Ack</span></code></td><td class="doc"><p>The command was received, Coq is processing it.</p></td></tr><tr id="type-answer_kind.Completed" class="anchored"><td class="def constructor"><a href="#type-answer_kind.Completed" class="anchor"></a><code>| </code><code><span class="constructor">Completed</span></code></td><td class="doc"><p>The command was completed.</p></td></tr><tr id="type-answer_kind.Added" class="anchored"><td class="def constructor"><a href="#type-answer_kind.Added" class="anchor"></a><code>| </code><code><span class="constructor">Added</span> <span class="keyword">of</span> Stateid.t * Loc.t * <span>[ `NewTip <span><span>| `Unfocus</span> of Stateid.t</span> ]</span></code></td><td class="doc"><p>A sentence was added, with corresponding sentence id and location.</p></td></tr><tr id="type-answer_kind.Canceled" class="anchored"><td class="def constructor"><a href="#type-answer_kind.Canceled" class="anchor"></a><code>| </code><code><span class="constructor">Canceled</span> <span class="keyword">of</span> <span>Stateid.t list</span></code></td><td class="doc"><p>A set of sentences are not valid anymore.</p></td></tr><tr id="type-answer_kind.ObjList" class="anchored"><td class="def constructor"><a href="#type-answer_kind.ObjList" class="anchor"></a><code>| </code><code><span class="constructor">ObjList</span> <span class="keyword">of</span> <span><a href="index.html#type-coq_object">coq_object</a> list</span></code></td><td class="doc"><p>Set of objects, usually the answer to a query</p></td></tr><tr id="type-answer_kind.CoqExn" class="anchored"><td class="def constructor"><a href="#type-answer_kind.CoqExn" class="anchor"></a><code>| </code><code><span class="constructor">CoqExn</span> <span class="keyword">of</span> <a href="ExnInfo/index.html#type-t">ExnInfo.t</a></code></td><td class="doc"><p>The command produced an error, optionally at a document location</p></td></tr></table></dt></dl></section><section><header><h4 id="entry-points-to-the-dsl-evaluator"><a href="#entry-points-to-the-dsl-evaluator" class="anchor"></a>Entry points to the DSL evaluator</h4></header><dl><dt class="spec value" id="val-exec_cmd"><a href="#val-exec_cmd" class="anchor"></a><code><span class="keyword">val</span> exec_cmd : <a href="index.html#type-cmd">cmd</a> <span>&#45;&gt;</span> <span><a href="index.html#type-answer_kind">answer_kind</a> list</span></code></dt><dd><p><code>exec_cmd cmd</code> execute SerAPI command</p></dd></dl><dl><dt class="spec type" id="type-cmd_tag"><a href="#type-cmd_tag" class="anchor"></a><code><span class="keyword">type</span> cmd_tag</code><code> = string</code></dt><dd><p>Each command and answer are tagged by a user-provided identifier</p></dd></dl><dl><dt class="spec type" id="type-tagged_cmd"><a href="#type-tagged_cmd" class="anchor"></a><code><span class="keyword">type</span> tagged_cmd</code><code> = <a href="index.html#type-cmd_tag">cmd_tag</a> * <a href="index.html#type-cmd">cmd</a></code></dt></dl><aside><p>We introduce our own feedback type to overcome some limitations of Coq's Feedback, for now we only modify the Message data</p></aside><dl><dt class="spec type" id="type-feedback_content"><a href="#type-feedback_content" class="anchor"></a><code><span class="keyword">type</span> feedback_content</code><code> = </code><table class="variant"><tr id="type-feedback_content.Processed" class="anchored"><td class="def constructor"><a href="#type-feedback_content.Processed" class="anchor"></a><code>| </code><code><span class="constructor">Processed</span></code></td></tr><tr id="type-feedback_content.Incomplete" class="anchored"><td class="def constructor"><a href="#type-feedback_content.Incomplete" class="anchor"></a><code>| </code><code><span class="constructor">Incomplete</span></code></td></tr><tr id="type-feedback_content.Complete" class="anchored"><td class="def constructor"><a href="#type-feedback_content.Complete" class="anchor"></a><code>| </code><code><span class="constructor">Complete</span></code></td></tr><tr id="type-feedback_content.ProcessingIn" class="anchored"><td class="def constructor"><a href="#type-feedback_content.ProcessingIn" class="anchor"></a><code>| </code><code><span class="constructor">ProcessingIn</span> <span class="keyword">of</span> string</code></td></tr><tr id="type-feedback_content.InProgress" class="anchored"><td class="def constructor"><a href="#type-feedback_content.InProgress" class="anchor"></a><code>| </code><code><span class="constructor">InProgress</span> <span class="keyword">of</span> int</code></td></tr><tr id="type-feedback_content.WorkerStatus" class="anchored"><td class="def constructor"><a href="#type-feedback_content.WorkerStatus" class="anchor"></a><code>| </code><code><span class="constructor">WorkerStatus</span> <span class="keyword">of</span> string * string</code></td></tr><tr id="type-feedback_content.AddedAxiom" class="anchored"><td class="def constructor"><a href="#type-feedback_content.AddedAxiom" class="anchor"></a><code>| </code><code><span class="constructor">AddedAxiom</span></code></td></tr><tr id="type-feedback_content.FileDependency" class="anchored"><td class="def constructor"><a href="#type-feedback_content.FileDependency" class="anchor"></a><code>| </code><code><span class="constructor">FileDependency</span> <span class="keyword">of</span> <span>string option</span> * string</code></td></tr><tr id="type-feedback_content.FileLoaded" class="anchored"><td class="def constructor"><a href="#type-feedback_content.FileLoaded" class="anchor"></a><code>| </code><code><span class="constructor">FileLoaded</span> <span class="keyword">of</span> string * string</code></td></tr><tr id="type-feedback_content.Message" class="anchored"><td class="def constructor"><a href="#type-feedback_content.Message" class="anchor"></a><code>| </code><code><span class="constructor">Message</span> <span class="keyword">of</span> </code><code>{</code><table class="record"><tr id="type-feedback_content.level" class="anchored"><td class="def field"><a href="#type-feedback_content.level" class="anchor"></a><code>level : Feedback.level;</code></td></tr><tr id="type-feedback_content.loc" class="anchored"><td class="def field"><a href="#type-feedback_content.loc" class="anchor"></a><code>loc : <span>Loc.t option</span>;</code></td></tr><tr id="type-feedback_content.pp" class="anchored"><td class="def field"><a href="#type-feedback_content.pp" class="anchor"></a><code>pp : Pp.t;</code></td></tr><tr id="type-feedback_content.str" class="anchored"><td class="def field"><a href="#type-feedback_content.str" class="anchor"></a><code>str : string;</code></td></tr></table><code>}</code></td></tr></table></dt><dt class="spec type" id="type-feedback"><a href="#type-feedback" class="anchor"></a><code><span class="keyword">type</span> feedback</code><code> = </code><code>{</code><table class="record"><tr id="type-feedback.doc_id" class="anchored"><td class="def field"><a href="#type-feedback.doc_id" class="anchor"></a><code>doc_id : Feedback.doc_id;</code></td></tr><tr id="type-feedback.span_id" class="anchored"><td class="def field"><a href="#type-feedback.span_id" class="anchor"></a><code>span_id : Stateid.t;</code></td></tr><tr id="type-feedback.route" class="anchored"><td class="def field"><a href="#type-feedback.route" class="anchor"></a><code>route : Feedback.route_id;</code></td></tr><tr id="type-feedback.contents" class="anchored"><td class="def field"><a href="#type-feedback.contents" class="anchor"></a><code>contents : <a href="index.html#type-feedback_content">feedback_content</a>;</code></td></tr></table><code>}</code></dt><dt class="spec type" id="type-answer"><a href="#type-answer" class="anchor"></a><code><span class="keyword">type</span> answer</code><code> = </code><table class="variant"><tr id="type-answer.Answer" class="anchored"><td class="def constructor"><a href="#type-answer.Answer" class="anchor"></a><code>| </code><code><span class="constructor">Answer</span> <span class="keyword">of</span> <a href="index.html#type-cmd_tag">cmd_tag</a> * <a href="index.html#type-answer_kind">answer_kind</a></code></td><td class="doc"><p>The answer is comming from a user-issued command</p></td></tr><tr id="type-answer.Feedback" class="anchored"><td class="def constructor"><a href="#type-answer.Feedback" class="anchor"></a><code>| </code><code><span class="constructor">Feedback</span> <span class="keyword">of</span> <a href="index.html#type-feedback">feedback</a></code></td><td class="doc"><p>Output produced by Coq (asynchronously)</p></td></tr></table></dt><dd><p>General answers of the protocol can be responses to commands, or Coq messages</p></dd></dl></section></section></div></body></html>